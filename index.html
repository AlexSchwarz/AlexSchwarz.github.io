<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Typing Invaders - Delta Time Update</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #000010; overflow: hidden; }
    #gameCanvas { display: block; margin: 0 auto; background: #000010; border: 2px solid #405080; transition: border-color 0.1s ease-out; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() { canvas.height = window.innerHeight; canvas.width = 600; }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // === Color Palette Constants ===
  const COLOR_BACKGROUND = "#000010"; const COLOR_STARS = "#FFFFFF"; const COLOR_PLAYER = "#00FF00";
  const COLOR_PLAYER_SHADOW = "#008000"; const COLOR_PLAYER_ERROR = "#FF0000"; const COLOR_PLAYER_ERROR_SHADOW = "#800000"; const COLOR_ENEMY_DEFAULT = "#FF8000"; const COLOR_ENEMY_LOCKED = "#FFFF00";
  const COLOR_ENEMY_PENDING = "#FFFFFF"; const COLOR_ENEMY_PENDING_SHADOW = "yellow"; const COLOR_ENEMY_HIT = "#FF0000"; const COLOR_ENEMY_HIT_SHADOW = "#800000"; const COLOR_PROJECTILE = "#00FF00";
  const COLOR_PROJECTILE_SHADOW = "#00FF00"; const COLOR_TEXT_UNMATCHED = "#FFFFFF"; const COLOR_TEXT_MATCHED = "#00FF00"; const COLOR_HUD_TEXT = "#FFFF00"; const COLOR_HUD_SHADOW = "#FFA500";
  const COLOR_HUD_BORDER = "#00FFFF"; const COLOR_METER_BORDER = "#FFFFFF"; const COLOR_METER_FILL_START = "#0080FF"; const COLOR_METER_FILL_END = "#80FFFF"; const COLOR_METER_GLOW = "#80FFFF";
  const COLOR_EXPLOSION_SMALL = "rgba(255, 100, 0, "; const COLOR_EXPLOSION_SMALL_SHADOW = "red"; const COLOR_EXPLOSION_LARGE = "rgba(255, 255, 150, "; const COLOR_EXPLOSION_LARGE_SHADOW = "orange"; const COLOR_ENGINE_GLOW = "rgba(255, 165, 0, 0.7)";

  // === Starfield Setup ===
  // Define speeds in Pixels Per Second (PPS) - TUNE THESE VALUES!
  const STAR_LAYER_PPS = [
    { count: 50, speedMinPPS: 10, speedMaxPPS: 25, size: 1, alpha: 0.5 }, // Slowest layer
    { count: 40, speedMinPPS: 30, speedMaxPPS: 50, size: 1.5, alpha: 0.8 }, // Medium layer
    { count: 30, speedMinPPS: 55, speedMaxPPS: 75, size: 2, alpha: 1.0 }  // Fastest layer
  ];
  let starField = [];

  function initStars() {
      starField = [];
      // Use the new PPS values
      STAR_LAYER_PPS.forEach((layer) => {
          for (let i = 0; i < layer.count; i++) {
              // Calculate speed in PPS
              const speedPPS = layer.speedMinPPS + Math.random() * (layer.speedMaxPPS - layer.speedMinPPS);
              starField.push({
                  x: Math.random() * canvas.width,
                  y: Math.random() * canvas.height,
                  size: layer.size,
                  speed: speedPPS, // Store speed in PPS
                  alpha: layer.alpha
              });
          }
      });
      starField.sort((a, b) => a.speed - b.speed); // Sort by PPS
  }

  // Modify updateStars to use dt
  function updateStars(dt) { // Added dt parameter
    starField.forEach(star=>{
      // --- Apply Delta Timing to Star Movement ---
      star.y += star.speed * dt; // speed is now in PPS
      // --- End Delta Timing Change ---
      if(star.y>canvas.height){ star.y=0; star.x=Math.random()*canvas.width; }
    });
  }

  // DrawStars remains the same
  function drawStars() { starField.forEach(star=>{ ctx.fillStyle=COLOR_STARS; ctx.globalAlpha = star.alpha; ctx.fillRect(star.x,star.y,star.size,star.size); }); ctx.globalAlpha = 1.0; }
  // === END Starfield ===

  const sourceWords = [
  // Length 3
  "ace", "aim", "ask", "bag", "big", "box", "cap", "cat", "cup", "den", "dog", "dry", "ear", "eat", "fly", "fog", "gap", "get", "hat", "hen", "ice", "ink", "jar", "jet", "key", "kin", "lap", "log", "map", "nap", "oar", "peg", "ram", "run", "sag", "sun", "tap", "top", "use", "van", "wax", "yet", "zip",
  // Length 4
  "able", "aqua", "bake", "blue", "calm", "code", "damp", "dark", "each", "echo", "fade", "fire", "gain", "game", "hack", "hike", "idea", "jade", "jump", "keen", "kite", "lake", "lava", "maze", "moon", "neat", "oath", "pace", "pink", "quad", "quiz", "race", "safe", "star", "talk", "task", "unit", "vast", "view", "wage", "yarn", "zone",
  // Length 5
  "about", "apple", "basic", "brave", "catch", "chase", "dance", "dream", "early", "earth", "faith", "field", "ghost", "giant", "happy", "image", "input", "jewel", "jolly", "khaki", "label", "laser", "magic", "noble", "ocean", "panel", "pixel", "queen", "quest", "raise", "robot", "scale", "scope", "table", "timer", "uncle", "ultra", "valid", "water", "yield", "zebra",
  // Length 6
  "aboard", "action", "beacon", "bounce", "camera", "cancel", "debate", "delete", "effect", "energy", "fabric", "format", "galaxy", "garden", "hacker", "handle", "impact", "jacket", "joystick", "kernel", "kettle", "launch", "letter", "market", "narrow", "object", "palace", "python", "random", "salary", "script", "target", "unique", "vector", "velvet", "waffle", "widget", "yellow", "zoning",
  // Length 7
  "abandon", "ability", "balance", "breathe", "capture", "decline", "develop", "eclipse", "execute", "factory", "firefly", "gallery", "gravity", "habitat", "history", "illegal", "install", "journey", "justify", "keyword", "kinetic", "landing", "library", "machine", "network", "operate", "package", "quality", "reality", "salvage", "tangent", "uniform", "venture", "welcome", "xylogen", "younger", "zealous",
  // Length 8
  "absolute", "activate", "backpack", "boundary", "calendar", "compiler", "damaging", "database", "economic", "ethernet", "facility", "function", "gasoline", "graphics", "habitual", "hardware", "identify", "internet", "joystick", "junction", "keyboard", "laminate", "language", "maintain", "navigate", "obedient", "parallel", "question", "rainfall", "saturate", "tangible", "ultimate", "valuable", "warranty", "yachting", "yourself", "zymology",
  // Length 9
  "abundance", "algorithm", "beautiful", "bandwidth", "calculate", "component", "dashboard", "debugging", "elaborate", "effective", "fabricate", "framework", "gitignore", "guarantee", "happiness", "hyperlink", "immediate", "interface", "javascript", "judgement", "keystroke", "knowledge", "landscape", "localhost", "magnitude", "narrative", "objective", "palatable", "qualified", "rearrange", "satellite", "technical", "uncertain", "vaccinate", "warehouse", "xenophobe", "yesterday", "zoologist",
  // Length 10
  "accessible", "accelerate", "background", "capability", "checkpoint", "deactivate", "deployment", "efficiency", "encryption", "filesystem", "generation", "historical", "horizontal", "illustrate", "initialize", "jeopardize", "kidnapping", "laboratory", "mechanical", "noticeable", "occupation", "percentage", "quarantine", "reasonable", "resolution", "scattering", "technology", "understand", "validation", "wastewater", "xenophobia", "youngsters", "zealousness",
  // Length 11
  "abandonment", "application", "calibration", "combination", "declaration", "electronics", "environment", "fabrication", "facilitate", "generalized", "handicapped", "immediately", "inheritance", "justification", "logarithmic", "maintenance", "manipulate", "necessitate", "observation", "painstaking", "placeholder", "qualitative", "realization", "satisfactory", "temperature", "unbelievable", "vaccination", "whereabouts", "xylocarpous", "yachtsmanship", "zooplankton",
  // Length 12
  "abbreviation", "asynchronous", "breakthrough", "broadcasting", "cancellation", "connectivity", "deliberation", "dependencies", "economically", "familiarized", "gastronomic", "headquarters", "illumination", "juxtaposition", "knowledgeable", "localization", "manufacturer", "neighborhood", "objectionable", "optimization", "particularly", "productivity", "quantitative", "radioactivity", "safeguarding", "technological", "transmission", "unacceptable", "vaporization", "virtualization", "weatherizing", "xylophonists", "yesterevening", "zealousnesses",
  // Length 13
  "accommodation", "authentication", "benchmarkable", "characteristic", "certification", "comprehension", "configuration", "demonstration", "documentation", "environmental", "exceptionally", "factorization", "fragmentation", "globalization", "hybridization", "identification", "implementation", "infrastructure", "intellisense", "liberalization", "magnification", "naturalization", "orchestration", "organizational", "participation", "quantification", "recommendation", "representation", "simplification", "synchronization", "transportation", "understanding", "waterproofing", "xenotransplant", "yachtclubbing", "zymotechniques",
  // Length 14
  "acknowledgment", "appropriateness", "collaboratively", "confidentiality", "contextualized", "decriminalized", "electromagnetic", "familiarization", "geolocalization", "homogenization", "instrumentation", "interoperability", "jurisdictional", "miniaturization", "nonnegotiable", "objectoriented", "parallelizable", "qualification", "rationalization", "standardization", "technologically", "transformation", "unconventional", "vascularization", "weatherability", "xerographically", "zwitterionicly",
  // Length 15
  "accompanimental", "biotransformation", "conceptualization", "decommodification", "environmentalism", "functionalization", "georeferencingly", "heterogeneously", "individualization", "juxtaposednesses", "knowledgeableness", "longitudinality", "microprocessing", "nationalistically", "operationalized", "professionalized", "quarterfinalist", "representational", "straightforwardly", "telecommunication", "uncontrollability", "weatherproofing", "xylophonistically", "zwitterionically"
];
  const newWordsEasy = sourceWords.filter(word => word.length >= 3 && word.length <= 4);
  const newWordsMedium = sourceWords.filter(word => word.length >= 5 && word.length <= 6);
  const newWordsHard = sourceWords.filter(word => word.length >= 7 && word.length <= 10);
  const newWordsVeryHard = sourceWords.filter(word => word.length >= 11 && word.length <= 15);

  // === Game State ===
  let gameState = 'start'; // 'start', 'waveStart', 'playing', 'gameOver', 'gameWon'
  let currentWave = 1;
  const maxWaves = 5;
  let enemies = [];
  let projectiles = [];
  let typed = "";
  let score = 0;
  let lastSpawnTime = 0;
  let totalKeystrokes = 0;
  let correctKeystrokes = 0;
  let explosions = [];
  let lockedEnemyId = null;
  let comboMeterCount = 0;
  const BASE_COMBO_MAX = 10;
  const COMBO_INCREASE_PER_MULTIPLIER = 5;
  let scoreMultiplier = 1;
  let consecutiveCombos = 0;
  const SCORE_PER_LETTER = 3;
  let keyHistory = [];
  const MAX_KEY_HISTORY = 15;
  let isShaking = false;
  const shakeDuration = 150;
  let shakeStartTime = 0;
  const shakeIntensity = 3; // Base shake intensity
  let errorFlashActive = false;
  const errorFlashDuration = 150;
  let errorFlashStartTime = 0;
  const defaultBorderColor = "#405080";
  const errorBorderColor = "red";
  const ENEMY_HIT_FLASH_DURATION = 120;
  let spawnInterval = 2000; // Base spawn interval, updated by wave config
  let enemyIdCounter = 1;
  // Wave-specific state
  let enemiesToSpawnThisWave = 0;
  let enemiesSpawnedThisWave = 0;
  let enemiesDestroyedThisWave = 0;

  // Define a base speed in Pixels Per Second - TUNE THIS VALUE!
  const BASE_ENEMY_PPS = 150; // Example: Pixels per second for a medium length word on wave 1
  // Define projectile speed in Pixels Per Second - TUNE THIS VALUE!
  const PROJECTILE_PPS = 1200; // Example value

  // Configure wave parameters (Updated again for specific difficulty mix & frequency)
  function getWaveConfig(wave) {
      switch(wave) {
          case 1: return {
            wordList: [...newWordsEasy],
              count: 20,
              interval: 800, // ms between spawns
              speedMultiplier: 1 // Multiplies BASE_ENEMY_PPS
          };
          case 2: return {
              wordList: [...newWordsEasy, ...newWordsMedium],
              count: 20,
              interval: 900,
              speedMultiplier: 1
          };
          case 3: return {
              wordList: [...newWordsEasy, ...newWordsMedium, ...newWordsHard],
              count: 20,
              interval: 1000,
              speedMultiplier: 1
          };
          case 4: return {
              wordList: [...newWordsEasy, ...newWordsMedium, ...newWordsHard, ...newWordsVeryHard],
              count: 20,
              interval: 1100,
              speedMultiplier: 1
          };
          case 5: return {
              wordList: [...newWordsEasy, ...newWordsMedium, ...newWordsHard, ...newWordsVeryHard],
              count: 20,
              interval: 1100,
              speedMultiplier: 1.1
          };
          default: return { // Fallback/Shouldn't happen
               wordList: newWordsEasy,
               count: 5,
               interval: 1000,
               speedMultiplier: 1
          };
      }
  }
  function resetGameState() {
      enemies=[]; projectiles=[]; typed=""; score=0; lastSpawnTime=0; totalKeystrokes=0; correctKeystrokes=0; explosions=[];
      lockedEnemyId=null;
      comboMeterCount=0; scoreMultiplier=1; consecutiveCombos=0; isShaking=false; errorFlashActive=false; canvas.style.borderColor=defaultBorderColor; enemyIdCounter=1; keyHistory = [];
      // Reset wave state
      currentWave = 1;
      enemiesToSpawnThisWave = 0;
      enemiesSpawnedThisWave = 0;
      enemiesDestroyedThisWave = 0;
  }

  function startGame() {
      // Can start from 'start', 'gameOver', or 'gameWon'
      if (gameState === 'start' || gameState === 'gameOver' || gameState === 'gameWon') {
          resetGameState();
          // Immediately go to the first wave start screen
          setupWave(currentWave);
          gameState = 'waveStart';
      }
  }

  // Setup parameters for the current wave
  function setupWave(wave) {
      const config = getWaveConfig(wave);
      enemiesToSpawnThisWave = config.count;
      spawnInterval = config.interval;
      enemiesSpawnedThisWave = 0;
      enemiesDestroyedThisWave = 0;
      // Clear any leftover state from previous wave/game
      enemies = [];
      projectiles = [];
      typed = "";
      lockedEnemyId = null;
      keyHistory = []; // Clear visual input history for new wave
  }

  // Select word based on current wave config
  function randomWord() {
      const config = getWaveConfig(currentWave);
      const list = config.wordList;
      if (!list || list.length === 0) {
        console.error("Word list is empty for wave:", currentWave);
        return "error"; // Fallback word
      }
      return list[Math.floor(Math.random()*list.length)];
  }

  // Spawn enemy, stopping after wave limit is reached
  function spawnEnemy() {
      // Check if we should spawn more enemies for this wave
      if (enemiesSpawnedThisWave >= enemiesToSpawnThisWave) {
          return; // Don't spawn more than planned for the wave
      }

      const word = randomWord();
      const config = getWaveConfig(currentWave); // Get speed multiplier
      const rf = 0.8 + 0.4 * Math.random(); // Random factor

      // --- New Speed Calculation (PPS) with Min/Max Limits ---
      // TUNE the baseline (5) or the BASE_ENEMY_PPS value
      let enemySpeedPPS = (BASE_ENEMY_PPS * config.speedMultiplier * rf) / (word.length / 5);

      // Apply Maximum Speed Limit - MAX_ENEMY_PPS defined near the top
      enemySpeedPPS = Math.min(160, enemySpeedPPS);

      // Apply Minimum Speed Limit - TUNE 20
      enemySpeedPPS = Math.max(30, enemySpeedPPS);
      // --- End New Speed Calculation ---

      const fontSize=16; ctx.font=`${fontSize}px 'Courier New'`; const textWidth=ctx.measureText(word).width; const pixelSize=5;
      const invaderPatternCols=7; const enemyVisualWidth=invaderPatternCols*pixelSize; const requiredWidth=Math.max(enemyVisualWidth,textWidth);
      const padding=10; const minX=(requiredWidth/2)+padding; const maxX=canvas.width-(requiredWidth/2)-padding;
      if(maxX<=minX){ console.warn(`Word "${word}" too long for screen width at wave ${currentWave}, skipping spawn.`); return; } const xPos=Math.random()*(maxX-minX)+minX;

      enemies.push({
          id: enemyIdCounter++,
          word,
          x: xPos,
          y: 0,
          speed: enemySpeedPPS, // Store speed in PPS
          isPendingDestruction: false,
          isHitFlashing: false,
          hitFlashStartTime: 0
      });
      enemiesSpawnedThisWave++;
  }


  function matchedPrefixLength(word, typedInput) { let mc=0; for(let i=0; i<word.length && i<typedInput.length; i++){ if(word[i]===typedInput[i]){mc++;}else{break;} } return mc; }

  function createExplosion(x, y, size='large') { let props={}; if(size==='small'){ props={r:0,mR:18,eR:0.9,a:0.9,fR:0.08,c:COLOR_EXPLOSION_SMALL,s:COLOR_EXPLOSION_SMALL_SHADOW,sB:10}; }else{ props={r:0,mR:45,eR:0.6,a:1.0,fR:0.02,c:COLOR_EXPLOSION_LARGE,s:COLOR_EXPLOSION_LARGE_SHADOW,sB:20}; } explosions.push({x,y, radius:props.r, maxRadius:props.mR, expandRate:props.eR, alpha:props.a, fadeRate:props.fR, color:props.c, shadow:props.s, shadowBlur:props.sB}); }
  function updateExplosions() { for(let i=explosions.length-1; i>=0; i--){ const ex=explosions[i]; ex.radius+=ex.expandRate; ex.alpha-=ex.fadeRate; if(ex.alpha<=0||ex.radius>=ex.maxRadius){ explosions.splice(i,1); } } }
  function drawExplosions() { explosions.forEach(ex=>{ ctx.beginPath(); ctx.arc(ex.x,ex.y,ex.radius,0,Math.PI*2); ctx.fillStyle=ex.color+`${ex.alpha})`; ctx.shadowColor=ex.shadow; ctx.shadowBlur=ex.shadowBlur; ctx.fill(); ctx.shadowBlur=0; }); }

  // Update projectile logic to track destroyed enemies
  function updateProjectiles(currentTime, dt) { // Added dt parameter
      for(let i=projectiles.length-1; i>=0; i--){
          const p=projectiles[i];
          const tE=enemies.find(e=>e.id===p.targetId);
          if(!tE){projectiles.splice(i,1); continue;} // Target gone

          const dx=tE.x-p.x; const dy=tE.y-p.y;
          const dist=Math.sqrt(dx*dx+dy*dy);
          const distanceToMove = PROJECTILE_PPS * dt; // How far the projectile moves this frame

          // Collision check: If distance is less than movement this frame OR a small threshold
          if(dist < distanceToMove || dist < 5) {
              if(p.type==='destroyer'){
                  createExplosion(tE.x,tE.y,'large');
                  const dId=p.targetId;
                  enemies=enemies.filter(e=>e.id!==dId); // Remove enemy
                  projectiles.splice(i,1); // Remove projectile
                  if(lockedEnemyId===dId){lockedEnemyId=null;} // Clear lock if it was the locked one
                  enemiesDestroyedThisWave++; // Track destroyed enemy for wave completion
                  continue; // Process next projectile
              }else if(p.type==='visual'){
                  if(!tE.isPendingDestruction){ // Don't hit-flash if already marked for destruction
                       createExplosion(tE.x,tE.y,'small');
                       tE.isHitFlashing = true;
                       tE.hitFlashStartTime = currentTime;
                  }
                  projectiles.splice(i,1); // Remove visual projectile
                  continue; // Process next projectile
              }
          } else { // Projectile still travelling
              const ang=Math.atan2(dy,dx);
              // --- Apply Delta Timing to Projectile Movement ---
              p.x += Math.cos(ang) * distanceToMove;
              p.y += Math.sin(ang) * distanceToMove;
              // --- End Delta Timing Change ---
          }
      }
  }
  function drawProjectiles() { projectiles.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fillStyle=COLOR_PROJECTILE; ctx.shadowColor=COLOR_PROJECTILE_SHADOW; ctx.shadowBlur=10; ctx.fill(); ctx.shadowBlur=0; }); }

  // === Update and Draw for PLAYING state ===
  function updatePlaying(currentTime, dt) { // Added dt parameter
      // Update effects timers (using currentTime as before is likely fine)
      if(isShaking && (performance.now()-shakeStartTime>=shakeDuration)){ isShaking=false; }
      if(errorFlashActive && (performance.now()-errorFlashStartTime>=errorFlashDuration)){ errorFlashActive=false; canvas.style.borderColor=defaultBorderColor; }
      enemies.forEach(enemy => { if (enemy.isHitFlashing && (currentTime - enemy.hitFlashStartTime >= ENEMY_HIT_FLASH_DURATION)) { enemy.isHitFlashing = false; } });

      // Spawn new enemies if needed (spawn logic doesn't need dt)
      if(enemiesSpawnedThisWave < enemiesToSpawnThisWave && currentTime-lastSpawnTime>spawnInterval){
          spawnEnemy();
          lastSpawnTime=currentTime;
      }

      // Update game elements - pass dt where needed
      updateStars(dt); // Pass dt
      updateProjectiles(currentTime, dt); // Pass currentTime and dt
      updateExplosions(); // Explosions are duration based, likely don't need dt

      // Update enemy positions and check for game over - Use dt
      for(let i=enemies.length-1; i>=0; i--){
          const enemy=enemies[i];
          if(!enemy.isPendingDestruction){
              // --- Apply Delta Timing to Enemy Movement ---
              enemy.y += enemy.speed * dt; // enemy.speed is now in PPS
              // --- End Delta Timing Change ---
          }
          // Check if enemy reached bottom
          if(enemy.y > canvas.height-20){ // Adjust Y threshold as needed
               gameState='gameOver';
               return; // Exit update loop immediately on game over
          }
      }

      // Check for wave completion (logic remains the same)
      if (enemiesSpawnedThisWave >= enemiesToSpawnThisWave && enemies.length === 0) {
          if (currentWave < maxWaves) {
              currentWave++;
              setupWave(currentWave); // Prepare for the next wave
              gameState = 'waveStart'; // Go to the wave start screen
          } else {
              // Last wave completed!
              gameState = 'gameWon';
          }
      }
  }

  function drawPlaying(currentTime) {
      drawStars();
      drawProjectiles();
      drawExplosions();
      drawShip();
      drawHUD(); // Score and Accuracy
      drawKeyHistory();
      // Current typed input visual
      drawComboMeter();
      drawMultiplier();
      // Draw current wave number during play
      ctx.font = "bold 18px Arial";
      ctx.fillStyle = COLOR_HUD_TEXT;
      ctx.textAlign = 'center';
      ctx.shadowColor = COLOR_HUD_SHADOW;
      ctx.shadowBlur = 5;
      ctx.fillText(`Wave: ${currentWave}/${maxWaves}`, canvas.width / 2, 30);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'start'; // Reset alignment

      // Draw enemies
      enemies.forEach(enemy=>{ drawEnemy(enemy,typed); });
  }
  // === END Update/Draw for PLAYING state ===

  // === Draw for START, WAVESTART, GAMEOVER, GAMEWON states ===
  function drawStartScreen() {
      drawStars();
      ctx.fillStyle=COLOR_STARS; ctx.font="40px Arial"; ctx.textAlign='center'; ctx.fillText("Typing Invaders",canvas.width/2,canvas.height/2-40); ctx.font="24px Arial";
      const startText = "Press SPACE to Start";
      const textY = canvas.height/2 + 20;
      // Blinking effect
      if(Math.floor(Date.now()/500)%2===0){ ctx.fillStyle=COLOR_HUD_TEXT;
      } else { ctx.fillStyle = COLOR_STARS;}
      ctx.fillText(startText,canvas.width/2, textY);
      ctx.textAlign='start';
  }

  function drawWaveStartScreen() {
      drawStars(); // Keep background dynamic
      ctx.fillStyle=COLOR_STARS; ctx.font="40px Arial"; ctx.textAlign='center'; ctx.fillText(`Wave ${currentWave} Incoming!`,canvas.width/2,canvas.height/2-80); // Adjusted Y position

      // --- Added Score and Accuracy Display ---
      ctx.font="20px Arial";
      ctx.fillStyle = COLOR_STARS;
      ctx.fillText("Score: "+score, canvas.width/2, canvas.height/2 - 20); // Display current score
      const accuracy = totalKeystrokes === 0 ? 100 : (correctKeystrokes / totalKeystrokes) * 100;
      ctx.fillText("Accuracy: "+accuracy.toFixed(1)+"%", canvas.width/2, canvas.height/2 + 10); // Display current accuracy
      // --- End Added Display ---

      ctx.font="24px Arial";
      const continueText = "Press SPACE to Begin";
      const textY = canvas.height / 2 + 60; // Adjusted Y position
      // Blinking effect
       if(Math.floor(Date.now()/500)%2===0){ ctx.fillStyle=COLOR_HUD_TEXT;
      } else { ctx.fillStyle = COLOR_STARS;}
      ctx.fillText(continueText,canvas.width/2, textY);
      // Optionally show wave specific info
      const config = getWaveConfig(currentWave);
      ctx.font="18px Arial";
      ctx.fillStyle = COLOR_STARS;
      // Non-blinking for info
      ctx.fillText(`Enemies: ${config.count}`, canvas.width/2, canvas.height/2 + 100); // Adjusted Y position
      ctx.textAlign='start';
  }

  function drawGameOverScreen() {
      drawStars(); ctx.fillStyle="rgba(0,0,0,0.7)"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle=COLOR_STARS; ctx.font="40px Arial"; ctx.textAlign='center'; ctx.fillText("GAME OVER",canvas.width/2,canvas.height/2-60); // Adjusted Y
      ctx.font="30px Arial"; ctx.fillText("Final Score: "+score,canvas.width/2,canvas.height/2-10); // Adjusted Y

      // --- Added Waves Completed Display ---
      const wavesCompleted = currentWave - 1; // Player failed on currentWave, so completed one less
      ctx.font="20px Arial";
      ctx.fillText("Waves Completed: " + wavesCompleted + "/" + maxWaves, canvas.width / 2, canvas.height / 2 + 20);
      // --- End Added Display ---

      const accuracy=totalKeystrokes===0?100:(correctKeystrokes/totalKeystrokes)*100; ctx.font="20px Arial"; ctx.fillText("Accuracy: "+accuracy.toFixed(1)+"%",canvas.width/2,canvas.height/2+50); // Adjusted Y
      ctx.font="22px Arial";
      const restartText = "Press SPACE to Play Again";
      const textY = canvas.height / 2 + 100; // Adjusted Y
      if(Math.floor(Date.now()/500)%2===0){ctx.fillStyle=COLOR_HUD_TEXT;}else{ctx.fillStyle=COLOR_STARS;} ctx.fillText(restartText, canvas.width/2, textY);
      ctx.textAlign='start';
   }

   function drawGameWonScreen() {
      drawStars(); ctx.fillStyle="rgba(0, 50, 0, 0.7)"; ctx.fillRect(0,0,canvas.width,canvas.height); // Greenish overlay
      ctx.fillStyle=COLOR_PLAYER; ctx.font="40px Arial"; ctx.textAlign='center'; ctx.fillText("YOU WON!",canvas.width/2,canvas.height/2-60); // Adjusted Y
      ctx.fillStyle=COLOR_STARS;
      ctx.font="30px Arial"; ctx.fillText("Final Score: "+score,canvas.width/2,canvas.height/2-10); // Adjusted Y

      // --- Added Waves Completed Display ---
      ctx.font="20px Arial";
      ctx.fillText("Waves Completed: " + maxWaves + "/" + maxWaves, canvas.width / 2, canvas.height / 2 + 20); // Display max waves as completed
      // --- End Added Display ---

      const accuracy=totalKeystrokes===0?100:(correctKeystrokes/totalKeystrokes)*100; ctx.font="20px Arial"; ctx.fillText("Accuracy: "+accuracy.toFixed(1)+"%",canvas.width/2,canvas.height/2+50); // Adjusted Y
      ctx.font="22px Arial"; const restartText = "Press SPACE to Play Again";
      const textY = canvas.height / 2 + 100; // Adjusted Y
      if(Math.floor(Date.now()/500)%2===0){ctx.fillStyle=COLOR_HUD_TEXT;}else{ctx.fillStyle=COLOR_STARS;} ctx.fillText(restartText, canvas.width/2, textY); ctx.textAlign='start';
   }


  // --- Component Drawing Functions ---
  function drawShip() { const pixelSize=5; const playerShipPattern=[[0,0,1,0,0],[0,1,1,1,0],[1,1,1,1,1],[1,0,1,0,1]]; const pR=playerShipPattern.length; const pC=playerShipPattern[0].length; const sW=pC*pixelSize; const sH=pR*pixelSize; const sX=canvas.width/2; const sBY=canvas.height-30; const startX=sX-sW/2; const startY=sBY-sH; const shipColor=errorFlashActive?COLOR_PLAYER_ERROR:COLOR_PLAYER; const shadowColor=errorFlashActive?COLOR_PLAYER_ERROR_SHADOW:COLOR_PLAYER_SHADOW; ctx.fillStyle=shipColor; ctx.shadowColor=shadowColor; ctx.shadowBlur=10; for(let r=0; r<pR; r++){ for(let c=0; c<pC; c++){ if(playerShipPattern[r][c]===1){ ctx.fillRect(startX+c*pixelSize,startY+r*pixelSize,pixelSize,pixelSize); } } } ctx.shadowBlur=0; if(!errorFlashActive){ const glowHeight=5+Math.random()*4; const glowY=sBY+2; ctx.fillStyle=COLOR_ENGINE_GLOW; ctx.shadowColor=COLOR_ENGINE_GLOW; ctx.shadowBlur=8; ctx.fillRect(sX-pixelSize*1.5,glowY,pixelSize,glowHeight); ctx.fillRect(sX+pixelSize*0.5,glowY,pixelSize,glowHeight); ctx.shadowBlur=0; } }
  function drawEnemy(enemy, typedInput) { const isLocked=(lockedEnemyId===enemy.id); const invaderColor=enemy.isPendingDestruction?COLOR_ENEMY_PENDING:(enemy.isHitFlashing?COLOR_ENEMY_HIT:(isLocked?COLOR_ENEMY_LOCKED:COLOR_ENEMY_DEFAULT)); const alpha=enemy.isPendingDestruction&&Math.floor(Date.now()/150)%2===0?0.5:1.0; ctx.globalAlpha=alpha; const fontSize=16; const pixelSize=5; const invaderPattern=[[0,1,0,0,0,1,0],[1,1,1,1,1,1,1],[1,0,1,1,1,0,1],[1,0,0,1,0,0,1],[0,1,1,0,1,1,0]]; const pR=invaderPattern.length; const pC=invaderPattern[0].length; const iW=pC*pixelSize; const iH=pR*pixelSize; const sX=enemy.x-iW/2; const iY=enemy.y-iH-5; ctx.fillStyle=invaderColor; ctx.shadowColor=enemy.isPendingDestruction?COLOR_ENEMY_PENDING_SHADOW:(enemy.isHitFlashing?COLOR_ENEMY_HIT_SHADOW:(isLocked?COLOR_ENEMY_LOCKED:invaderColor)); ctx.shadowBlur=isLocked||enemy.isPendingDestruction||enemy.isHitFlashing?12:5; for(let r=0; r<pR; r++){ for(let c=0; c<pC; c++){ if(invaderPattern[r][c]===1){ ctx.fillRect(sX+c*pixelSize,iY+r*pixelSize,pixelSize,pixelSize); } } } ctx.shadowBlur=0; ctx.font=`${fontSize}px 'Courier New'`; ctx.textAlign='center'; const textY=enemy.y+10; if(enemy.isPendingDestruction){ ctx.fillStyle=COLOR_TEXT_MATCHED; ctx.fillText(enemy.word,enemy.x,textY); }else{ const currentTyped=(isLocked)?typedInput:""; const matchCount=matchedPrefixLength(enemy.word,currentTyped); const matchedText=enemy.word.substring(0,matchCount); const unmatchedText=enemy.word.substring(matchCount); const fTW=ctx.measureText(enemy.word).width; const textStartX=enemy.x-fTW/2; if(isLocked&&matchCount>0){ ctx.fillStyle=COLOR_TEXT_MATCHED; const mW=ctx.measureText(matchedText).width; ctx.fillText(matchedText,textStartX+mW/2,textY); } ctx.fillStyle=COLOR_TEXT_UNMATCHED; const uW=ctx.measureText(unmatchedText).width; const mWV=ctx.measureText(matchedText).width; ctx.fillText(unmatchedText, textStartX+mWV+uW/2, textY); } ctx.textAlign='start'; ctx.globalAlpha=1.0; }
  function drawHUD() { const hudFontSize="bold 20px Arial"; const hudColor=COLOR_HUD_TEXT; const shadowColor=COLOR_HUD_SHADOW; const shadowBlur=5; const topPadding=30; const boxPadding=5; ctx.font=hudFontSize; ctx.textAlign='left'; const accuracy=totalKeystrokes===0?100:(correctKeystrokes/totalKeystrokes)*100; const accText=accuracy.toFixed(1)+"%"; const accMetrics=ctx.measureText(accText); ctx.strokeStyle=COLOR_HUD_BORDER; ctx.lineWidth=1; ctx.strokeRect(10-boxPadding,topPadding-18-boxPadding,accMetrics.width+boxPadding*2,20+boxPadding*2); ctx.fillStyle=hudColor; ctx.shadowColor=shadowColor; ctx.shadowBlur=shadowBlur; ctx.fillText(accText,10,topPadding); ctx.font=hudFontSize; ctx.textAlign='right'; const scoreText=String(score); const scoreMetrics=ctx.measureText(scoreText); ctx.strokeStyle=COLOR_HUD_BORDER; ctx.lineWidth=1; ctx.strokeRect(canvas.width-10-scoreMetrics.width-boxPadding,topPadding-18-boxPadding,scoreMetrics.width+boxPadding*2,20+boxPadding*2); ctx.fillStyle=hudColor; ctx.shadowColor=shadowColor; ctx.shadowBlur=shadowBlur; ctx.fillText(scoreText,canvas.width-10,topPadding); ctx.shadowBlur=0; ctx.textAlign='start'; }
  function drawComboMeter() { const mH=10; const mW=canvas.width; const mX=0; const mY=canvas.height-mH-5; const currentComboMax=BASE_COMBO_MAX+(scoreMultiplier-1)*COMBO_INCREASE_PER_MULTIPLIER; ctx.strokeStyle=COLOR_METER_BORDER; ctx.lineWidth=1; ctx.strokeRect(mX,mY,mW,mH); if(comboMeterCount>0){ const fillRatio=comboMeterCount/currentComboMax; const fillWidth=mW*fillRatio; const gradient=ctx.createLinearGradient(mX,mY,mX+mW,mY); gradient.addColorStop(0,COLOR_METER_FILL_START); gradient.addColorStop(1,COLOR_METER_FILL_END); ctx.fillStyle=gradient; ctx.shadowColor=COLOR_METER_GLOW; ctx.shadowBlur=10; ctx.fillRect(mX,mY,fillWidth,mH); ctx.shadowBlur=0; } }
  function drawMultiplier() { if(scoreMultiplier>1){ const shipX=canvas.width/2; const shipTopY=canvas.height-30-30; const displayX=shipX+30; const displayY=shipTopY+20; ctx.font="bold 24px Arial"; ctx.fillStyle=COLOR_HUD_TEXT; ctx.shadowColor=COLOR_HUD_SHADOW; ctx.shadowBlur=8; ctx.textAlign='left'; ctx.fillText(`x${scoreMultiplier}`,displayX,displayY); ctx.shadowBlur=0; ctx.textAlign='start'; } }
  function drawKeyHistory() { if(keyHistory.length>0){ const displayY=60; const fontSize=18; ctx.font=`${fontSize}px 'Courier New', monospace`; ctx.textBaseline='middle'; let totalWidth=0; keyHistory.forEach(entry=>{ totalWidth+=ctx.measureText(entry.char).width; }); let currentX=canvas.width/2-totalWidth/2; keyHistory.forEach(entry=>{ ctx.fillStyle=entry.correct?COLOR_TEXT_MATCHED:COLOR_PLAYER_ERROR; ctx.shadowBlur=0; ctx.fillText(entry.char,currentX,displayY); currentX+=ctx.measureText(entry.char).width; }); ctx.textBaseline='alphabetic'; } }
  // --- END Component Drawing Functions ---

  // =========================================
  // === Global Input Listener ===
  // =========================================
  window.addEventListener("keydown", (e) => {
      const keyTime = performance.now(); // Use performance.now() for consistency

      // --- Handle SPACE for state transitions ---
      if (e.code === 'Space') {
          if (gameState === 'start' || gameState === 'gameOver' || gameState === 'gameWon') {
              startGame();
              e.preventDefault(); // Prevent space scrolling page
              return;
          }
          // Handle space on Wave Start screen
          if (gameState === 'waveStart') {
              gameState = 'playing';
              lastSpawnTime = performance.now(); // Start spawning for the wave
              // Reset lastTimestamp for dt calculation at the start of play
              lastTimestamp = 0;
              e.preventDefault();
              return;
          }
      }

      // --- Input Handling for PLAYING state ---
      if (gameState === 'playing') {

          // --- Handle Backspace ---
          if (e.code === 'Backspace') {
              if (lockedEnemyId !== null || typed !== "") {
                  typed = "";
                  lockedEnemyId = null;
                  keyHistory = []; // Clear visual input too when backspacing
                  // Reset combo as the chain is broken
                  comboMeterCount = 0;
                  consecutiveCombos = 0;
                  scoreMultiplier = 1;
              }
              e.preventDefault(); // Prevent browser back navigation
              return; // Don't process as a letter
          }

          // --- Handle Letters ---
          if(!/^[a-zA-Z]$/.test(e.key)) return; // Only accept letters

          totalKeystrokes++;
          const newChar = e.key.toLowerCase();
          let projectileType='visual';
          let projectileTargetId=-1;
          let fireProjectile=false;
          let correctKeyPressed=false;
          let clearHistoryForNewWord = false; // Flag to control history clearing

          // Determine correctness BEFORE changing state
          if(lockedEnemyId!==null){
              const lockedEnemy=enemies.find(e=>e.id===lockedEnemyId);
              if(lockedEnemy && !lockedEnemy.isPendingDestruction){
                  const potentialString=typed+newChar;
                  correctKeyPressed = lockedEnemy.word.startsWith(potentialString);
              } else {
                  // Locked enemy disappeared or pending destruction, check if new char matches any other enemy start
                  lockedEnemyId = null; // Lose lock
                  typed = ""; // Clear typed progress
                  const matchingEnemies=enemies.filter(enemy=>!enemy.isPendingDestruction&&enemy.word.startsWith(newChar));
                  correctKeyPressed = matchingEnemies.length > 0;
                  if (correctKeyPressed) { clearHistoryForNewWord = true; } // Mark history to be cleared
              }
          } else { // No enemy currently locked
              const matchingEnemies=enemies.filter(enemy=>!enemy.isPendingDestruction&&enemy.word.startsWith(newChar));
              correctKeyPressed = matchingEnemies.length > 0;
              if (correctKeyPressed) { clearHistoryForNewWord = true; } // Mark history to be cleared
          }

          // Store history entry data (will be pushed later)
          const historyEntry = { char: newChar, correct: correctKeyPressed };

          // Clear history *before* pushing the new character if starting a new word
          if (clearHistoryForNewWord) {
              keyHistory = [];
          }

          // Apply game logic based on correctness
          if(correctKeyPressed){
              correctKeystrokes++;
              score+=SCORE_PER_LETTER*scoreMultiplier;

              // Lock onto new enemy if needed (and not already locked)
              if(lockedEnemyId===null){ // Only lock if starting fresh or lock was lost
                  const potentialString=newChar; // Start matching with the current correct key
                  const matchingEnemies=enemies.filter(enemy=>!enemy.isPendingDestruction&&enemy.word.startsWith(potentialString));
                  if (matchingEnemies.length > 0) {
                      let closestEnemy = null;
                      let minDistanceSq = Infinity; // Use squared distance to avoid sqrt

                      // Player ship position (approximate bottom-center)
                      const playerX = canvas.width / 2;
                      const playerY = canvas.height - 30; // Reference point on the ship

                      matchingEnemies.forEach(enemy => {
                          const dx = enemy.x - playerX;
                          const dy = enemy.y - playerY;
                          const distanceSq = dx*dx + dy*dy; // Squared distance

                          if (distanceSq < minDistanceSq) {
                              minDistanceSq = distanceSq;
                              closestEnemy = enemy;
                          }
                      });

                      // Lock onto the closest enemy found
                      if (closestEnemy) {
                          lockedEnemyId=closestEnemy.id;
                          typed = newChar; // Start typing with the first correct char
                      } else {
                          // Fallback if something went wrong (shouldn't happen if matchingEnemies > 0)
                          correctKeyPressed = false; // Treat as incorrect
                          typed = "";
                      }

                  } else {
                     // No enemies match the starting character
                     correctKeyPressed = false; // Treat as incorrect if no enemy matches
                     typed = "";
                  }

              } else {
                 // Already locked, just append the character
                 typed += newChar;
              }


              // Process typing on locked enemy (if lock was successful or maintained)
              if(lockedEnemyId!==null){
                  const lockedEnemy=enemies.find(e=>e.id===lockedEnemyId);
                  if(lockedEnemy && !lockedEnemy.isPendingDestruction){ // Check again if enemy still valid
                      // typed was already updated above
                      fireProjectile=true;
                      projectileTargetId=lockedEnemy.id;
                      const isCompletion=(lockedEnemy.word===typed);
                      if(isCompletion){
                          projectileType='destroyer';
                          lockedEnemy.isPendingDestruction=true;
                          // Don't clear typed here, wait for projectile logic.
                      } else {
                          projectileType='visual';
                      }
                  } else {
                     // Locked enemy disappeared between check and now
                     lockedEnemyId = null;
                     typed = "";
                     correctKeyPressed = false; // Treat as incorrect for combo/effects
                     fireProjectile = false; // Don't fire
                  }
              }

              // Push to history AFTER potential clear and state update
              keyHistory.push(historyEntry);
              if (keyHistory.length > MAX_KEY_HISTORY) { keyHistory.shift(); }

              // Combo Meter Update (only if key was truly correct and processed)
              if (correctKeyPressed) {
                  comboMeterCount++;
                  const currentComboMax=BASE_COMBO_MAX+(scoreMultiplier-1)*COMBO_INCREASE_PER_MULTIPLIER;
                  if(comboMeterCount>=currentComboMax){
                      consecutiveCombos++;
                      scoreMultiplier=1+consecutiveCombos;
                      comboMeterCount=0;
                  }
              }


              // Fire Projectile
              if(fireProjectile && projectileTargetId !== -1){
                  const startX=canvas.width/2;
                  const startY=canvas.height-40; // Projectile origin
                  projectiles.push({x:startX,y:startY,targetId:projectileTargetId,type:projectileType});
                  // If it was a destroyer, immediately clear lock/typed
                  if (projectileType === 'destroyer') {
                     lockedEnemyId = null;
                     typed = "";
                     // History persists until next word starts.
                  }
              }

          } else { // Incorrect Key Press
              // Push incorrect key to history
              keyHistory.push(historyEntry);
              if (keyHistory.length > MAX_KEY_HISTORY) { keyHistory.shift(); }

              // Reset combo and apply effects
              comboMeterCount=0;
              consecutiveCombos=0;
              scoreMultiplier=1;
              if (!isShaking) { isShaking = true; shakeStartTime = keyTime; }
              if (!errorFlashActive) { errorFlashActive = true; errorFlashStartTime = keyTime; canvas.style.borderColor = errorBorderColor; }
          }
      } // End playing state input handling
  });
  // =========================================
  // === END Global Input Listener ===
  // =========================================

  // === Main Game Loop ===
  let lastTimestamp = 0; // Variable to store the timestamp of the last frame

  function gameLoop(currentTime) { // currentTime is provided by requestAnimationFrame
      // Calculate delta time (time elapsed since last frame in milliseconds)
      if (lastTimestamp === 0) {
          lastTimestamp = currentTime; // Initialize on the first frame
      }
      let deltaTime = currentTime - lastTimestamp;
      lastTimestamp = currentTime;

      // Optional: Clamp delta time to prevent huge jumps if the tab loses focus
      const maxDeltaTime = 100; // Max time step in ms (e.g., equivalent to 10 FPS)
      // Use a smaller clamp for smoother recovery, e.g. 33ms (~30fps limit) if preferred
      // const maxDeltaTime = 33;
      if (deltaTime > maxDeltaTime) {
           // console.warn(`DeltaTime clamped from ${deltaTime.toFixed(1)}ms to ${maxDeltaTime}ms`); // Optional warning
           deltaTime = maxDeltaTime;
      }

      // Convert deltaTime to seconds (standard for physics calculations)
      const dt = deltaTime / 1000.0;

      // --- Rendering ---
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();

      // Apply screen shake if active
      if(isShaking && gameState === 'playing'){
          const elapsed = performance.now() - shakeStartTime;
          // Check if shake duration has passed *before* calculating intensity
          if (elapsed < shakeDuration) {
            const shakeProgress = elapsed / shakeDuration; // 0 to 1
            const currentIntensity = shakeIntensity * (1 - shakeProgress * shakeProgress); // Intensity decreases faster towards the end
            const shakeX = Math.sin(elapsed / 15) * currentIntensity; // Use varying intensity
            const shakeY = Math.cos(elapsed / 20) * currentIntensity;
            ctx.translate(shakeX, shakeY);
          } else {
             isShaking = false; // Ensure shaking stops
          }
      }


      // Game state logic and drawing - Pass dt where needed
      switch (gameState) {
          case 'start':
              updateStars(dt); // Pass dt
              drawStartScreen();
              break;
          case 'waveStart':
              updateStars(dt); // Pass dt
              drawWaveStartScreen();
              break;
          case 'playing':
              // Pass both currentTime (for timers) and dt (for movement)
              updatePlaying(currentTime, dt);
              // Only draw if not game over after update
              if (gameState === 'playing') {
                  drawPlaying(currentTime); // Drawing doesn't usually need dt directly
              }
              break;
          case 'gameOver':
              updateStars(dt); // Pass dt
              drawGameOverScreen();
              break;
          case 'gameWon':
               updateStars(dt); // Pass dt
               drawGameWonScreen();
               break;
      }

      ctx.restore();
      // --- End Rendering ---

      requestAnimationFrame(gameLoop); // Loop forever
  }
  // === END Main Game Loop ===

  // --- Initial Setup ---
  initStars();
  // Start the loop; lastTimestamp will be set on the first frame run.
  requestAnimationFrame(gameLoop);

</script>
</body>
</html>
